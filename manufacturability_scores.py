# -*- coding: utf-8 -*-
"""Manufacturability Scores

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L80ljjPkHZiY4QOTRDiumwdwM4O27K8M
"""

import cv2
import math
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
import numpy as np
import sys, time

def isBlack(cv2Image, y, x):
  b, g, r = cv2Image[y, x]
  if b<127 and g <127 and r<127:
    return True
  return False

def numLayers(cv2Image):
  highest = 0
  lowest = 0
  y, x = cv2Image.shape[:2]
  white = True
  while white:
    for i in range(x):
      for j in range(y):
        if isBlack(cv2Image, j, i):
          white = False
          break
      if white ==False:
        break
    break
  highest = i
  white = True
  while white:
    for i in range(x-1, 1, -1):
      for j in range(y-1,1, -1):
        if isBlack(cv2Image, j, i):
          white = False
          break
      if white ==False:
        break
    break
  lowest = j
  return lowest-highest+1

def supportArea(cv2Image):
  count=0
  y, x = cv2Image.shape[:2]
  for i in range(x):
    for j in range(y-1):
      if isBlack(cv2Image, j, i):
        if isBlack(cv2Image, j+1, i) == False:
          count+=1
          cv2Image[j+1, i] = (0, 0, 255)

  cv2_imshow(cv2Image)
  return count

def supportVolume(cv2Image):
  count = 0
  blackAbove = True
  y, x = cv2Image.shape[:2]
  for i in range(x):
    for j in range(y-1):
      if isBlack(cv2Image, j, i):
        for k in range(j, 39):
          if isBlack(cv2Image, k, i) == False:
            if (cv2Image.item(k, i, 1) == 0) and (cv2Image.item(k, i, 2) == 255):
              pass
            else:
              cv2Image[k, i] = (0, 0, 255)
      b, g, r = cv2Image[j, i]
      if b==0 and g == 0 and r == 255:
        count+=1
  cv2_imshow(cv2Image)
  return count

def clusters(cv2Image):
  currentCount = []
  counted = []
  clusters = []
  image = cv2.imread('1.png')
  y, x = image.shape[:2]
  red = True
  total = supportVolume(cv2Image)

  while total>0:
    y, x = 40, 120
    while red:
      for i in range(x):
        for j in range(y):
          b, g, r = cv2Image[j, i]
          if b == 0 and g == 0 and r == 255:
            if (j, i) not in counted:
              red = False
              currentCount.append((j, i))
              break
        if red == False:
          break
      break

    for pixel in currentCount:
      y, x = pixel
      b, g, r = image[y, x]
      if b != 255 or g != 255 or r != 255:
        currentCount.remove(pixel)
      cv2Image[y, x] = (255, 0, 255)
      b, g, r = cv2Image[y, x + 1]
      if b == 0 and g == 0 and r == 255:
        if (y, x + 1) not in currentCount:
          currentCount.append((y, x + 1))

      b, g, r = cv2Image[y + 1, x]
      if b == 0 and g == 0 and r == 255:
        if (y + 1, x) not in currentCount:
          currentCount.append((y + 1, x))

      b, g, r = cv2Image[y - 1, x]
      if b == 0 and g == 0 and r == 255:
        if (y - 1, x) not in currentCount:
          currentCount.append((y - 1, x))

      if b == 0 and g == 0 and r == 255:
        if (y, x - 1) not in currentCount:
          currentCount.append((y, x - 1))

    counted.extend(currentCount)
    clusters.append(len(currentCount))
    total-=len(currentCount)
    currentCount.clear()
    red = True
    cv2_imshow(cv2Image)

  score = 0
  for number in clusters:
    score += (1/number)

  return score

def thinRegions():
  blacks = []
  whites = []
  distances =  []
  score = 0
  image = cv2.imread('1.png')
  y, x = image.shape[:2]
  for i in range(x):
    for j in range(y):
      if isBlack(image, j , i):
        blacks.append((j, i))
      else:
        whites.append((j, i))

  for black in blacks:
    distance = 1000
    (j_1, i_1) = black
    for white in whites:
      (j_2, i_2) = white
      dis = math.sqrt(pow(j_1-j_2, 2) + pow(i_1-i_2, 2))
      if dis < distance:
        distance = dis
    distances.append(distance)
  for d in distances:
    score += 1/d
  return score

def u(s, a):

    if (abs(s) >= 0) & (abs(s) <= 1):
        return (a+2)*(abs(s)**3)-(a+3)*(abs(s)**2)+1

    elif (abs(s) > 1) & (abs(s) <= 2):
        return a*(abs(s)**3)-(5*a)*(abs(s)**2)+(8*a)*abs(s)-4*a
    return 0

def padding(img, H, W, C):
    zimg = np.zeros((H+4, W+4, C))
    zimg[2:H+2, 2:W+2, :C] = img

    zimg[2:H+2, 0:2, :C] = img[:, 0:1, :C]
    zimg[H+2:H+4, 2:W+2, :] = img[H-1:H, :, :]
    zimg[2:H+2, W+2:W+4, :] = img[:, W-1:W, :]
    zimg[0:2, 2:W+2, :C] = img[0:1, :, :C]
    zimg[0:2, 0:2, :C] = img[0, 0, :C]
    zimg[H+2:H+4, 0:2, :C] = img[H-1, 0, :C]
    zimg[H+2:H+4, W+2:W+4, :C] = img[H-1, W-1, :C]
    zimg[0:2, W+2:W+4, :C] = img[0, W-1, :C]

    return zimg

def bicubic(img, ratio, a):

    H, W, C = img.shape
    img = padding(img, H, W, C)
    dH = math.floor(H*ratio)
    dW = math.floor(W*ratio)
    dst = np.zeros((dH, dW, 3))
    h = 1/ratio
    inc = 0

    for c in range(C):
        for j in range(dH):
            for i in range(dW):
                x, y = i * h + 2, j * h + 2
                x1 = 1 + x - math.floor(x)
                x2 = x - math.floor(x)
                x3 = math.floor(x) + 1 - x
                x4 = math.floor(x) + 2 - x
                y1 = 1 + y - math.floor(y)
                y2 = y - math.floor(y)
                y3 = math.floor(y) + 1 - y
                y4 = math.floor(y) + 2 - y
                mat_l = np.matrix([[u(x1, a), u(x2, a), u(x3, a), u(x4, a)]])
                mat_m = np.matrix([[img[int(y-y1), int(x-x1), c],
                                    img[int(y-y2), int(x-x1), c],
                                    img[int(y+y3), int(x-x1), c],
                                    img[int(y+y4), int(x-x1), c]],
                                   [img[int(y-y1), int(x-x2), c],
                                    img[int(y-y2), int(x-x2), c],
                                    img[int(y+y3), int(x-x2), c],
                                    img[int(y+y4), int(x-x2), c]],
                                   [img[int(y-y1), int(x+x3), c],
                                    img[int(y-y2), int(x+x3), c],
                                    img[int(y+y3), int(x+x3), c],
                                    img[int(y+y4), int(x+x3), c]],
                                   [img[int(y-y1), int(x+x4), c],
                                    img[int(y-y2), int(x+x4), c],
                                    img[int(y+y3), int(x+x4), c],
                                    img[int(y+y4), int(x+x4), c]]])
                mat_r = np.matrix(
                    [[u(y1, a)], [u(y2, a)], [u(y3, a)], [u(y4, a)]])
                dst[j, i, c] = np.dot(np.dot(mat_l, mat_m), mat_r)
    sys.stderr.write('\n')
    sys.stderr.flush()
    return dst
image = cv2.imread('1.png')
ratio = 3
a = 1/3
dst = bicubic(image, ratio, a)
cv2.imwrite('bicubic.png', dst)
bicubicImg=cv2.imread('bicubic.png')
cv2_imshow(bicubicImg)
print(str(bicubicImg.shape))

equations = []
angles = []
img = cv2.imread('bicubic.png')
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
img_blur = cv2.GaussianBlur(img_gray, (3,3), 0)
edges = cv2.Canny(image=img_blur, threshold1=100, threshold2=200)
cv2_imshow(edges)

# Detect points that form a line
lines = cv2.HoughLinesP(edges, 1, np.pi/180, threshold = 30, minLineLength=10, maxLineGap=15)
# Draw lines on the image
i=0
for line in lines:
    x1, y1, x2, y2 = line[0]
    A = -(y2-y1)
    B = -(x1-x2)
    C = A*x1+B*y1
    equations.append([A, B, C, (x1, y1), (x2, y2)])
    i+=1
    cv2.line(img, (x1, y1), (x2, y2), (0, 255, 0), 2)

for i in range(len(equations)):
  for j in range(len(equations)):
    if i !=j:
      A1, B1, C1, pt1, pt2 = equations[i]
      A2, B2, C2, pt1, pt2 = equations[j]
      det = A1 * B2 - A2 * B1
      if det == 0:
        counter=0
        break
      else:
        x = (B2 * C1 - B1 * C2) / det
        y = (A1 * C2 - A2 * C1) / det
        slope1 = -A1/B1
        slope2 = -A2/B2
        x1, y1 = pt1
        x2, y2 = pt2
        if x1>x2 and y1>y2:
          if x>x2 and x<x1 and y>y2 and y<y1:
            angles.append(180/math.pi * math.atan(abs((slope2-slope1) / (1+slope1*slope2))))
        elif x2>x1 and y1>y2:
          if x>x1 and x<x2 and y>y2 and y<y1:
            angles.append(180/math.pi * math.atan(abs((slope2-slope1) / (1+slope1*slope2))))
        elif x1>x2 and y2>y1:
          if x>x2 and x<x1 and y>y1 and y<y2:
            angles.append(180/math.pi * math.atan(abs((slope2-slope1) / (1+slope1*slope2))))
        elif x2>x1 and y2>y1:
          if x>x1 and x<x2 and y>y1 and y<y2:
            angles.append(180/math.pi * math.atan(abs((slope2-slope1) / (1+slope1*slope2))))
counter = 0
for angle in range(len(angles)):
   if angles[angle] < 45:
     counter+=1

cv2_imshow(img)
counter = (int)(counter/2)
print(counter)

image = cv2.imread('1.png')
cv2_imshow(image)
print(numLayers(image))
print(supportArea(image))
print(supportVolume(image))
print(clusters(image))
print(thinRegions())